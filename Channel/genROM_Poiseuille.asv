%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Generate ROM for Couette flow using controllability
% The controllability Gramian is approximated using resolvent analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear
close all;
clc
addpath(genpath('aux_functions'));

set(groot,'defaulttextInterpreter','latex')
set(groot,'defaultAxesTickLabelInterpreter','latex'); 
set(groot,'defaultColorbarTickLabelInterpreter','latex'); 
set(groot,'defaultLegendInterpreter','latex');
set(0,'defaultfigureunits','inches');
set(0,'defaultfigureposition',[7 7 6 4.5])
set(0,'DefaultLineLinewidth',2);
set(0,'DefaultAxesFontSize',18);
set(0,'DefaultFigureColor','remove')
set(0,'DefaultFigureColor',[1 1 1])

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Domain parameters (adapt to avoid aliasing)                  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Nx      = 6;                    % Number of grid points in the streamwise direction
Nz      = 6;                    % Number of grid points in the spanwise direction
Ny      = 129;                  % Number of grid points in the wall-normal direction
Lx      = 2.0*pi;               % Streamwise domain size
Lz      = 1.0*pi;               % Spanwise domain size


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Grid generation                 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Wall-normal grid (Chebyshev discretisation)
[y,A]   = chebdif(Ny,2);        % Chebyshev grid in the wall-normal direction
[~,W]   = clencurt(Ny-1);       % Clenshaw-Curtis quadrature weights
Wcol    = repmat(W.',Nx*Nz,1);
W       = diag(W);
Dy      = squeeze(A(:,:,1));    % Differentiation matrix
Dy2     = squeeze(A(:,:,2));    % Second-order differentiation


% x-z grid (homegeneous directions, Fourier discretisation)
[x,Dx]  = fourdif(Nx,1);
[~,Dx2] = fourdif(Nx,2);
[z,Dz]  = fourdif(Nz,1);
[~,Dz2] = fourdif(Nz,2);

% Scaling x-z grid
facx    = Lx/(2*pi); x = x*facx; Dx = Dx/facx; Dx2 = Dx2/facx^2;
facz    = Lz/(2*pi); z = z*facz; Dz = Dz/facz; Dz2 = Dz2/facz^2;
dx      = x(2)-x(1);
dz      = z(2)-z(1);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ROM parameters              
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Base flow
Recalc      = 100; % Retau
U           = 1.5*(1-y.^2); % Poiseuille
np          = Ny;
ne          = np*Nx*Nz;
nalphas     = 1;
nmodesy     = 16; % number of controllability modes
ngammas     = 1;
alphas      = (0:nalphas)*2*pi/Lx;
gammas      = (-ngammas:1:ngammas)*2*pi/Lz;
gref        = 2*pi/Lz;
[a,g]       = meshgrid(alphas,gammas);

%nmodes =  length(a)*2*nmodesy;
[X,Y,Z]=meshgrid(x,y,z);


Wf = 0.5/(Nx*Nz)*spdiags(Wcol,0,length(Wcol),length(Wcol));

phiaux = zeros(size(X,1),size(X,2),size(X,3),3,size(a,1),size(a,2),nmodesy);
avec = zeros(size(a,1),size(a,2),nmodesy);
gvec = avec; bvec = avec;

for i=1:size(a,1)
    for j=1:size(a,2)
        a(i,j)
        g(i,j)
        q = modalbasis_cntrl_res3(a(i,j),g(i,j),U,Recalc,nmodesy,x,z);
        avec(i,j,:,:) = a(i,j);
        gvec(i,j,:,:) = g(i,j);
        for k=1:nmodesy
            bvec(i,j,k,:) = k;
            
            %fu = q(1:ne,k);
            %fv = q(ne+1:2*ne,k);
            %fw = q(2*ne+1:3*ne,k);
            
            phi1 = reshape(q(:,k),[3*np,Nx,Nz,1]);
            
            phiaux(:,:,:,1,i,j,k) = phi1(1:np,:,:);
            phiaux(:,:,:,2,i,j,k) = phi1(np+1:2*np,:,:);
            phiaux(:,:,:,3,i,j,k) = phi1(2*np+1:3*np,:,:);
        end
    end
end

phi = phiaux(:,:,:,:,:);
nmodes = size(phi,5);

avec = avec(:);
gvec = gvec(:);
kvec = [avec gvec];
bvec = bvec(:);

%% throw away (0,-gamma) modes
pos = find(~((kvec(:,1)==0)&kvec(:,2)<0))
phi = phi(:,:,:,:,pos);
kvec = kvec(pos,:);
bvec = bvec(pos,:);
nmodes = length(pos);
 
%% throw away modes with non-zero mass flux
if(nomass)
for i=1:nmodes
    massaux = zeros(size(phi,1),size(phi,2),size(phi,3),size(phi,4));
    massaux(:,:,:,1) = 1.0;
    Mass(i) = inprod(squeeze(phi(:,:,:,:,i)),massaux,dx,dz,W);
end
pos=find(abs(Mass)<1e-8);
phi = phi(:,:,:,:,pos);
kvec = kvec(pos,:);
bvec = bvec(pos,:);
Phases = Phases(pos);
nmodes = length(pos);
end


%%
M = zeros(nmodes,nmodes);
for i=1:nmodes
    disp(['Inner products in basis, ' num2str(i) '/' num2str(nmodes)])
    for j=1:nmodes
%        M(i,j) = inprod(squeeze(phi(:,:,:,:,i)),squeeze(phi(:,:,:,:,j)),dx,dz,W);
        M(i,j) = inprod_s(squeeze(phi(:,:,:,:,i)),squeeze(phi(:,:,:,:,j)),Wf);
    end
end
disp(['Maximum non-orthogonality: ' num2str(max(max(M-diag(diag(M)))))]);

% remove modes that are zero, or that have zero wavenumber
normmode = diag(M);
pos = find((normmode>1e-6));
disp(['Number of 0-norm modes: ' int2str(nmodes - length(pos))]);
phi=squeeze(phi(:,:,:,:,pos));
M = M(pos,pos);
nmodes = length(pos);
kvec = kvec(pos,:);
bvec = bvec(pos,:);

%normalise
for i=1:nmodes
   phi(:,:,:,:,i) = phi(:,:,:,:,i)/sqrt(M(i,i));
   M(i,i) = M(i,i)/M(i,i);
end

phix = phi;
phixx = phi;
phiy = phi;
phiyy = phi;
phiz = phi;
phizz = phi;

%%
phi0 = zeros(size(phi,1),size(phi,2),size(phi,3),3);
%phi0(:,:,:,1) = Recalc/2*(1-Y.^2); %
%phi0(:,:,:,1) = 1.5*(1-Y.^2); % laminar solution, cf. PRF
 

% differentiate
for i=1:nmodes
    disp(['Differentiation, ' num2str(i) '/' num2str(nmodes)])

    for j=1:Ny
        for k=1:Nz
            phix(j,:,k,:,i) = Dx*squeeze(phi(j,:,k,:,i));
            phixx(j,:,k,:,i) = Dx2*squeeze(phi(j,:,k,:,i));
        end
    end
    for j=1:Nx
        for k=1:Nz
            phiy(:,j,k,:,i) = Dy*squeeze(phi(:,j,k,:,i));
            phiyy(:,j,k,:,i) = Dy2*squeeze(phi(:,j,k,:,i));
        end
    end
    for j=1:Ny
        for k=1:Nx
            phiz(j,k,:,:,i) = Dz*squeeze(phi(j,k,:,:,i));
            phizz(j,k,:,:,i) = Dz2*squeeze(phi(j,k,:,:,i));
        end
    end
end
    for j=1:Ny
        for k=1:Nz
            phi0x(j,:,k,:) = Dx*squeeze(phi0(j,:,k,:));
        end
    end
    for j=1:Nx
        for k=1:Nz
            phi0y(:,j,k,:) = Dy*squeeze(phi0(:,j,k,:));
        end
    end
    for j=1:Ny
        for k=1:Nx
            phi0z(j,k,:,:) = Dz*squeeze(phi0(j,k,:,:));
        end
    end

Lapl = phixx+phiyy+phizz;

% check if divergence free
divU = zeros(nmodes,1);
for i=1:nmodes
divU(i) = max(max(max(abs(squeeze(phix(:,:,:,1,i)) + squeeze(phiy(:,:,:,2,i)) + squeeze(phiz(:,:,:,3,i))))))
end
disp(['Max. divergence = ' num2str(max(max(max(max(abs(divU)))))) ]);
pos=find(divU>0.01);
disp('Wavenumbers with non-zero divergence: ');
kvec(pos,:)
%pause
% figure;
% ii = 1; jj = 19;
% plot(y,squeeze(abs(phi(1:Ny,1,1,1,ii))),'k-',y,squeeze(abs(phi(1:Ny,1,1,1,jj))),'ks')
% hold on;
% plot(y,squeeze(abs(phi(1:Ny,1,1,2,ii))),'b-',y,squeeze(abs(phi(1:Ny,1,1,2,jj))),'bs')
% plot(y,squeeze(abs(phi(1:Ny,1,1,3,ii))),'r-',y,squeeze(abs(phi(1:Ny,1,1,3,jj))),'rs')


% pos=find(divU<1e-6);
% disp('Wavenumbers with zero divergence: ');
% kvec(pos,:)

% % for the time being, throw away modes that have non-zero divergence
% pos2 = find(divU<1e-5);
% phi = phi(:,:,:,:,pos2);
% phix = phix(:,:,:,:,pos2);
% phiy = phiy(:,:,:,:,pos2);
% phiz = phiz(:,:,:,:,pos2);
% Lapl = Lapl(:,:,:,:,pos2);
% nmodes = length(pos2);
% a1 = a1(pos2); b1 = b1(pos2); g1 = g1(pos2); kk = kk(pos2);

%pause

%% operators in Galerkin projection
for i=1:nmodes
    disp(['Linear term, ' num2str(i) '/' num2str(nmodes)])
    for j=1:nmodes
%        L(i,j) = inprod(phi(:,:,:,:,i),Lapl(:,:,:,:,j),dx,dz,W);
        L(i,j) = inprod_s(phi(:,:,:,:,i),Lapl(:,:,:,:,j),Wf);
    end
end

for i=1:nmodes
    disp(['Linear term 2, ' num2str(i) '/' num2str(nmodes)])
    f1=squeeze(phi(:,:,:,:,i));

    for j=1:nmodes
            f2 = zeros(size(f1));
            f2(:,:,:,1) = phi(:,:,:,1,j).*phi0x(:,:,:,1) + phi(:,:,:,2,j).*phi0y(:,:,:,1) + phi(:,:,:,3,j).*phi0z(:,:,:,1);
            f2(:,:,:,2) = phi(:,:,:,1,j).*phi0x(:,:,:,2) + phi(:,:,:,2,j).*phi0y(:,:,:,2) + phi(:,:,:,3,j).*phi0z(:,:,:,2);
            f2(:,:,:,3) = phi(:,:,:,1,j).*phi0x(:,:,:,3) + phi(:,:,:,2,j).*phi0y(:,:,:,3) + phi(:,:,:,3,j).*phi0z(:,:,:,3);

            f2(:,:,:,1) = f2(:,:,:,1) + phix(:,:,:,1,j).*phi0(:,:,:,1) + phiy(:,:,:,1,j).*phi0(:,:,:,2) + phiz(:,:,:,1,j).*phi0(:,:,:,3);
            f2(:,:,:,2) = f2(:,:,:,2) + phix(:,:,:,2,j).*phi0(:,:,:,1) + phiy(:,:,:,2,j).*phi0(:,:,:,2) + phiz(:,:,:,2,j).*phi0(:,:,:,3);
            f2(:,:,:,3) = f2(:,:,:,3) + phix(:,:,:,3,j).*phi0(:,:,:,1) + phiy(:,:,:,3,j).*phi0(:,:,:,2) + phiz(:,:,:,3,j).*phi0(:,:,:,3);
%            L2(i,j) = -inprod(f1,f2,dx,dz,W);
            L2(i,j) = -inprod_s(f1,f2,Wf);
    end
end

% to add constant advection in x
for i=1:nmodes
    disp(['Linear term 3, ' num2str(i) '/' num2str(nmodes)])
    f1=squeeze(phi(:,:,:,:,i));

    for j=1:nmodes
            f2 = zeros(size(f1));

            f2(:,:,:,1) = f2(:,:,:,1) + phix(:,:,:,1,j);
            f2(:,:,:,2) = f2(:,:,:,2) + phix(:,:,:,2,j);
            f2(:,:,:,3) = f2(:,:,:,3) + phix(:,:,:,3,j);
            L3(i,j) = -inprod_s(f1,f2,Wf);
    end
end

% to add constant advection in z
for i=1:nmodes
    disp(['Linear term 4, ' num2str(i) '/' num2str(nmodes)])
    f1=squeeze(phi(:,:,:,:,i));

    for j=1:nmodes
            f2 = zeros(size(f1));
            f2(:,:,:,1) = f2(:,:,:,1) + phiz(:,:,:,1,j);
            f2(:,:,:,2) = f2(:,:,:,2) + phiz(:,:,:,2,j);
            f2(:,:,:,3) = f2(:,:,:,3) + phiz(:,:,:,3,j);
            L4(i,j) = -inprod_s(f1,f2,Wf);
    end
end

%pause
Q = zeros(nmodes,nmodes,nmodes);
parpool(24);
parfor i=1:nmodes
    tic;
    disp(['Quadratic term, ' num2str(i) '/' num2str(nmodes)])
    f1=squeeze(phi(:,:,:,:,i));
    for j=1:nmodes
        for k=1:nmodes
            f2 = zeros(size(f1));
            f2(:,:,:,1) = phi(:,:,:,1,j).*phix(:,:,:,1,k) + phi(:,:,:,2,j).*phiy(:,:,:,1,k) + phi(:,:,:,3,j).*phiz(:,:,:,1,k);
            f2(:,:,:,2) = phi(:,:,:,1,j).*phix(:,:,:,2,k) + phi(:,:,:,2,j).*phiy(:,:,:,2,k) + phi(:,:,:,3,j).*phiz(:,:,:,2,k);
            f2(:,:,:,3) = phi(:,:,:,1,j).*phix(:,:,:,3,k) + phi(:,:,:,2,j).*phiy(:,:,:,3,k) + phi(:,:,:,3,j).*phiz(:,:,:,3,k);
            Q(i,j,k) = -inprod_s(f1,f2,Wf);
% 	if(k~=j)
%            f2 = zeros(size(f1));
%            f2(:,:,:,1) = phi(:,:,:,1,k).*phix(:,:,:,1,j) + phi(:,:,:,2,k).*phiy(:,:,:,1,j) + phi(:,:,:,3,k).*phiz(:,:,:,1,j);
%            f2(:,:,:,2) = phi(:,:,:,1,k).*phix(:,:,:,2,j) + phi(:,:,:,2,k).*phiy(:,:,:,2,j) + phi(:,:,:,3,k).*phiz(:,:,:,2,j);
%            f2(:,:,:,3) = phi(:,:,:,1,k).*phix(:,:,:,3,j) + phi(:,:,:,2,k).*phiy(:,:,:,3,j) + phi(:,:,:,3,k).*phiz(:,:,:,3,j);
%            Q(i,j,k) = Q(i,j,k)-inprod_s(f1,f2,Wf);
%	end
        end
    end
    toc
end

for i=1:nmodes
	for j=1:nmodes
		for k=1:(j-1)
			Q(i,j,k) = Q(i,j,k)+Q(i,k,j);
			Q(i,k,j) = 0;
		end
	end
end

QQ = zeros(nmodes,nmodes^2);
%parpool(24);
for i=1:nmodes
%    if(mod(i,10)==0)
        i
%    end
            Qaux = squeeze(Q(i,:,:)); Qaux = Qaux(:).';
            QQ(i,:) = (Qaux);
end
% cond = QQ>1e-6;
% [i,j,~] = find(cond);
% s = diag(QQ(i,j));% s = s(:);
% [m,n] = size(cond);
% QQ = sparse(i,j,s,m,n);

QQ = sparse((abs(QQ)>1e-8).*QQ);


outfile = ['galerkin_model_cnt_' int2str(nalphas) '_' int2str(nmodesy) '_' int2str(ngammas) '_Lx_' num2str(Lx/pi) '_Lz_' num2str(Lz/pi) '_Re_' num2str(Recalc) '.mat'];
save(outfile,'L','L2','L3','L4','Q','QQ','phi','phi0','phix','phiy','phiz','X','Y','Z','Wf','W','avec','bvec','gvec','kvec','alphas','gammas','Nx','Ny','Nz','-v7.3');
 
