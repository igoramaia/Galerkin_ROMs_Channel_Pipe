%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Generate ROM for pipe flow using controllability modes
% The controllability Gramian is approximated using resolvent analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear
close all;
clc
addpath(genpath('aux_functions'));

set(groot,'defaulttextInterpreter','latex')
set(groot,'defaultAxesTickLabelInterpreter','latex'); 
set(groot,'defaultColorbarTickLabelInterpreter','latex'); 
set(groot,'defaultLegendInterpreter','latex');
set(0,'defaultfigureunits','inches');
set(0,'defaultfigureposition',[7 7 6 4.5])
set(0,'DefaultLineLinewidth',2);
set(0,'DefaultAxesFontSize',18);
set(0,'DefaultFigureColor','remove')
set(0,'DefaultFigureColor',[1 1 1])

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ROM and domain parameters                 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Re_bas      = 100;                 % Reynolds number for basis obtention
m_max       = 1;                   % Máximum multiple of fundamental wavenumber (azimuthal direction)
alfa_max    = 1;                   % Máximum multiple of fundamental wavenumber (stremwise direction)
Lx          = (4/3)*pi;            % Streamwise domain size
Lm          = (2/3)*pi;            % Azimuthal domain size

Nr          = 64;                  % Radial discretisation
Nm          = 4*m_max + 2;         % Azimuthal discretisation
Nx          = 4*alfa_max + 2;      % Streamwise discretisation
nmodesy     = 16;                  % Controllability modes per wavenumber

m           = (-m_max:m_max)*(2*pi/Lm);  % Azimuthal wavenumber vector
alphas      = (0:alfa_max)*(2*pi/Lx);    % Streamwise wavenumber vector
[a,g]       = meshgrid(alphas,m);

% Domain and differentiation matrices

[r, ~]      = chebdif(2*Nr, 1);     % Generate with 2*Nr points because the r>0 half of the domain is excluded
r           = r(r > 0);             % Nr points
[Dr, Dr2, ~]= DiffMat(Nr, r, 5);    % 4th order finite difference
[x, Dx]     = fourdif(Nx, 1);       % Fourier differentiation matrices
[~, Dx2]    = fourdif(Nx, 2);
[theta, Dm] = fourdif(Nm, 1);
[~, Dm2]    = fourdif(Nm, 2);

% Rescaling the domain
x           = x*(Lx/(2*pi));
Dx          = Dx/(Lx/(2*pi));
Dx2         = Dx2/(Lx/(2*pi))^2;
theta       = theta*(Lm/(2*pi));
Dm          = Dm/(Lm/(2*pi));
Dm2         = Dm2/(Lm/(2*pi))^2;

% Base flow
Ubase = 1 - r.^2;

% Integration weights
[~, weights] = clencurt(2*Nr - 1);
weights      = weights(1:Nr).*r'; % Vezes r porque o elemento de integração em coordenadas cilíndricas é r*dr
W            = diag([weights weights weights]);
W_half       = sqrtm(W);

weights_rep  = repmat(weights.', Nx*Nm, 1);
W            = 0.5/(Nx*Nm)*spdiags(weights_rep, 0, length(weights_rep), length(weights_rep));
Z            = zeros(size(W));
Wg           = [W, Z, Z;
                Z, W, Z;
                Z, Z, W];
clear weights weights_rep W Z

% Frequencies for resolvent analysis
nomega              = 21;           % Number of frequencies per wavenumber
modos_res_per_omega = 50;           % Number of resolvent modes per frequency

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Create modal basis                     
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

phi         = zeros(Nr, Nx, Nm, 3, length(alphas), length(m), nmodesy);
avec        = zeros(length(alphas),length(m),nmodesy);
gvec        = avec;

for i = 1:length(alphas)
    omega                           = linspace(-1.5*alphas(i), 1.5*alphas(i), nomega);
    for j = 1:length(m)
        avec(i,j,:)                 = alphas(i);
        gvec(i,j,:)                 = m(j);
        U_control                   = modalbasis_cntrl_res_pipe(diag(Ubase), diag(r), x, theta, Re_bas, alphas(i), omega, m(j), Dr, Dr2, W_half, Wg, Nr, Nx, Nm, modos_res_per_omega, nmodesy);
        U_control                   = reshape(U_control, [3*Nr, Nx, Nm, nmodesy]);
        % Ignore modes with zero streamwise wavenumber and negative azimuthal wavenumber 
        if ~(alphas(i) == 0 && m(j) < 0)
            % Preenche a matriz Phi com as 3 componentes dos modos para o i-ésimo valor de alfa e o j-ésimo valor de m
            phi(:, :, :, 1, i, j, :) = U_control(1:Nr, :, :, :);        % ux
            phi(:, :, :, 2, i, j, :) = U_control(Nr+1:2*Nr, :, :, :);   % ur
            phi(:, :, :, 3, i, j, :) = U_control(2*Nr+1:3*Nr, :, :, :); % um
        end
    end

end

phi         = phi(:, :, :, :, :);
avec        = avec(:);
gvec        = gvec(:);
kvec        = [avec gvec];      % Vector with wavenumber pairs contained in the basis

% Orthogonality test
fprintf('Maximum non-orthogonality: ')
M           = orthogonality_test(phi, Wg); % M(i, j) = produto interno entre o modo i e o modo j
fprintf('%e\n', max(abs(M - diag(diag(M))), [], 'all'))

% Discard modes with zero norm
non_zero_norm = find(diag(M) > 1e-6);
M             = M(non_zero_norm, non_zero_norm);
phi           = phi(:, :, :, :, non_zero_norm);
nmodes        = size(phi, 5);
fprintf('Modos com norma não nula: %d\n', nmodes)

% Normalise modes
for i=1:nmodes
   phi(:,:,:,:,i)   = phi(:,:,:,:,i)/sqrt(M(i,i));
   M(i,i)           = M(i,i)/M(i,i);
end

clear M

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Compute ROM operators (see mathematical details in papers)  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% dq/dt = (1/Re)L_{ij}a_{j} + L2_{ij}a_{j} +Q_{ikj}a_{j}a_{k}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Differentiation
phi_r       = phi;
phi_rr      = phi; 
phi_x       = phi; 
phi_xx      = phi; 
phi_m       = phi; 
phi_mm      = phi; 

for i = 1:nmodes
    % r derivatives
    for j = 1:Nx
        for k = 1:Nm
            phi_r(:, j, k, :, i)  = Dr*squeeze(phi(:, j, k, :, i));
            phi_rr(:, j, k, :, i) = Dr2*squeeze(phi(:, j, k, :, i));
        end
    end
    % x derivatives
    for j = 1:Nr
        for k = 1:Nm
            phi_x(j, :, k, :, i)  = Dx*squeeze(phi(j, :, k, :, i));
            phi_xx(j, :, k, :, i) = Dx2*squeeze(phi(j, :, k, :, i));
        end
    end
    % Derivadas em relação a theta
    for j = 1:Nr
        for k = 1:Nx
            phi_m(j, k, :, :, i)  = Dm*squeeze(phi(j, k, :, :, i));
            phi_mm(j, k, :, :, i) = Dm2*squeeze(phi(j, k, :, :, i));
        end
    end
end

% Verify zero-divergence condition
Div         = zeros(nmodes, 1);
for i = 1:nmodes
    Div(i)   = max(abs(phi_x(:, :, :, 1, i) + (1./r).*phi(:, :, :, 2, i) + phi_r(:, :, :, 2, i) + (1./r).*phi_m(:, :, :, 3, i)), [], 'all');
end
fprintf('Maximum divergence: %e\n', max(Div))



% Operators in Galerkin projection

L         = zeros(nmodes, nmodes);
for i = 1:nmodes
    % Phi_i
    phi_i = phi(:, :, :, :, i);
    phi_i = phi_i(:);
    for j = 1:nmodes
        Lapl_Phi_j             = zeros(Nr, Nx, Nm, 3);
        
        Lapl_Phi_j(:, :, :, 1) = phi_xx(:, :, :, 1, j) + (1./r).*(phi_r(:, :, :, 1, j)) + phi_rr(:, :, :, 1, j) + (1./r.^2).*phi_mm(:, :, :, 1, j);
        
        Lapl_Phi_j(:, :, :, 2) = phi_xx(:, :, :, 2, j) + (1./r).*(phi_r(:, :, :, 2, j)) + phi_rr(:, :, :, 2, j) + (1./r.^2).*phi_mm(:, :, :, 2, j) ...
            - (1./r.^2).*phi(:, :, :, 2, j) - (2./r.^2).*phi_m(:, :, :, 3, j);
        
        Lapl_Phi_j(:, :, :, 3) = phi_xx(:, :, :, 3, j) + (1./r).*(phi_r(:, :, :, 3, j)) + phi_rr(:, :, :, 3, j) + (1./r.^2).*phi_mm(:, :, :, 3, j) ...
            - (1./r.^2).*phi(:, :, :, 3, j) + (2./r.^2).*phi_m(:, :, :, 2, j);
        
        Lapl_Phi_j             = Lapl_Phi_j(:);
        
        L(i, j) = Lapl_Phi_j'*Wg*phi_i;
    end
end

% Quadratic convective term term
Q = zeros(nmodes, nmodes, nmodes);
parpool(24); % Parallel computing
parfor i = 1:nmodes
    % Phi_i
    phi_i = Phi(:, :, :, :, i);
    phi_i = phi_i(:);
    for j = 1:nmodes
        for k = 1:nmodes
            % (Phi_j*Grad) Phi_k = [Comp. x of Phi_j*(d/dx)] Phi_k + [Comp. r of Phi_j*(d/dr)] Phi_k + [(1/r)*Comp. theta of Phi_j*(d/dtheta)] Phi_k
            Phi_j_Grad_Phi_k = Phi(:, :, :, 1, j).*phi_x(:, :, :, :, k) + Phi(:, :, :, 2, j).*phi_r(:, :, :, :, k) + (1./r).*Phi(:, :, :, 3, j).*phi_m(:, :, :, :, k);
            Phi_j_Grad_Phi_k = Phi_j_Grad_Phi_k(:);
            % <Phi_i, (Phi_j*Grad) Phi_k>
            Q(i, j, k) = -Phi_j_Grad_Phi_k'*Wg*phi_i;
        end
    end
end
clear Phi_j_Grad_Phi_k phi_i

%% Finaliza o programa
% Salva os resultados obtidos
out = "ROM_Galerkin_pipe" + length(alphas) + "_alphas_" + length(m) + "_ms_" + "_alpha_max_" + alfa_max + "_m_max_" + m_max + ...
    "_Ncontrol_" + Ncontrol + "_Nr_" + Nr + "_Nx_" + Nx + "_Nm_" + Nm + "_Modos_" + nmodes + "_Re_" + Re +".mat";
save(out, 'L', 'Q', 'Phi', 'phi_x', 'phi_r', 'phi_m', 'r', 'x', 'theta', 'Wg', 'alfa', 'm', 'Nx', 'Nr', 'Nm', 'nmodes', 'kvec');
